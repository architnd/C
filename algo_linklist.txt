Algorithm create(*H)
{
   temp = H;
   repeat until choice = 'y'
   {
       allocate memory to curr;
       accept curr->data;
       curr->next = NULL;
       temp->next = curr;
       temp = curr;     // temp = temp->next
       Read choice;
   }
}

Algorithm display(*H)
{
   if H->next == NULL
        Print "List is empty"
   else
   {
        curr = H->next;
        while(curr != NULL)
        {
            Print curr->data;
            curr = curr->next;
        }
   }
}

Algorithm len(*H)
{
   curr = H->next;
   i = 0;
   while(curr != NULL)
   {
        i++;
        curr = curr->next;
   }
   return(i);
}

Algorithm Insertbypos(*H)
{
   i = 1; curr = H;
   allocate memory for nnode;
   read nnode->data and pos;
   k = len();
   if(pos > k+1)
       Print "Data can't be inserted";
   else
   {
       while(curr != NULL && i < pos)
       {
           i++;
           curr = curr->next;
       }
       nnode->next = curr->next;
       curr->next = nnode;
   }
}

Algorithm delpos(*H)
{
   prev = H; ctr = 1;
   curr = H->next;
   read pos;
   k = len();
   if (k < pos)
        Print "Data can't be deleted";
   else
   {
       while(ctr < pos && curr != NULL)
       {
           ctr++;
           prev = curr;
           curr = curr->next;
       }
       temp = curr;
       prev->next = curr->next;
       curr->next = NULL;
       free(temp);
   }
}

Algorithm reverse(*H)
{
   prev = NULL;
   curr = head->next;
   while(curr != NULL)
   {
        future = curr->next;
        curr->next = prev;
        prev = curr;
        curr = future;
   }
   head->next = prev;
}

Algorithm sort(*H)
{
   len = len(H);
   for i = 1 to len-1
   {
       prev = H;
       curr = H->next;
       for j = 0 to < len-i
       {
           temp = curr->next;
           if(curr->data > temp->data)
           {
               prev->next = temp;
               curr->next = temp->next;
               temp->next = curr;
               prev = temp;
           }
           else
           {
               prev = curr;
               curr = curr->next;
           }
       }
   }
}

Algorithm merge(*H1, *H2)
{
   curr1 = H1->next;
   curr2 = H2->next;

   if(curr1->data < curr2->data)
   { temp = head1; flag = 1; }
   else
   { temp = head2; flag = 0; }

   while(curr1 != NULL && curr2 != NULL)
   {
       if(curr1->data < curr2->data)
       {
           temp->next = curr1;
           temp = curr1;
           curr1 = curr1->next;
       }
       else
       {
           temp->next = curr2;
           temp = curr2;
           curr2 = curr2->next;
       }
   }
   if(curr1 == NULL) temp->next = curr2;
   if(curr2 == NULL) temp->next = curr1;

   if(flag == 1) display(head1);
   else display(head2);
}
void merge_lists(struct node **head1, struct node **head2, struct node **head3) {
    struct node *curr1 = *head1;
    struct node *curr2 = *head2;
    int prn;
    char name[50];

    // If one of the lists is empty, the merged list is just the other list
    if (curr1 == NULL) {
        *head3 = *head2;  // Copy second list to head3
        *head1 = NULL;
        *head2 = NULL;
        return;
    }
    if (curr2 == NULL) {
        *head3 = *head1;  // Copy first list to head3
        *head1 = NULL;
        *head2 = NULL;
        return;
    }

    // Merge the lists using insert_by_pos to maintain order in head3
    while (curr1 != NULL && curr2 != NULL) {
        if (curr1->prn < curr2->prn) {
            // Insert current node from list 1 into head3
            prn = curr1->prn;
            strcpy(name, curr1->name);
            insert_by_pos(head3, get_length(*head3), prn, name);  // Insert at the end of head3
            curr1 = curr1->next;
        } else {
            // Insert current node from list 2 into head3
            prn = curr2->prn;
            strcpy(name, curr2->name);
            insert_by_pos(head3, get_length(*head3), prn, name);  // Insert at the end of head3
            curr2 = curr2->next;
        }
    }

    // If there are remaining nodes in list1
    while (curr1 != NULL) {
        prn = curr1->prn;
        strcpy(name, curr1->name);
        insert_by_pos(head3, get_length(*head3), prn, name);  // Insert at the end of head3
        curr1 = curr1->next;
    }

    // If there are remaining nodes in list2
    while (curr2 != NULL) {
        prn = curr2->prn;
        strcpy(name, curr2->name);
        insert_by_pos(head3, get_length(*head3), prn, name);  // Insert at the end of head3
        curr2 = curr2->next;
    }

    // Set the other lists to NULL (they are now merged)
    *head1 = NULL;
    *head2 = NULL;
}
void sort_by_prn(struct node **head) {
    int len = get_length(*head);
    if (len <= 1) return;

    struct node *temp;
    int i, j;

    // Outer loop to go through each node
    for (i = 1; i < len; i++) {
        temp = *head;  // Start from the head for each iteration

        // Inner loop for pairwise comparison
        for (j = 0; j < len - i; j++) {
            struct node *next = temp->next;
            if (next == NULL) break;

            // If current node's prn > next node's prn, swap data
            if (temp->prn > next->prn) {
                // Swap the PRN and Name between temp and next
                int temp_prn = temp->prn;
                char temp_name[50];
                strcpy(temp_name, temp->name);  // Save the name of temp

                // Swap the PRN
                temp->prn = next->prn;
                strcpy(temp->name, next->name);  // Swap the name

                next->prn = temp_prn;
                strcpy(next->name, temp_name);  // Restore the name for next

            }

            // Move to the next node
            temp = temp->next;
        }
    }
}

int compare_lists(struct node **head, struct node **head2) {
    struct node *temp = *head;
    struct node *temp2 = *head2;
    while (temp != NULL && temp2 != NULL) {
        int cmp = strcmp(temp->name, temp2->name);
        if (temp->prn != temp2->prn || cmp != 0) {
            return 0;
        }
        temp = temp->next;
        temp2 = temp2->next;
    }
    if (temp == NULL && temp2 == NULL) {
        return 1;  // Lists are equal
    }
    return 0;
}

int compare_lists(struct node **head, struct node **head2){
    struct node *temp = *head;
    struct node *temp2 = *head2;
    int cmp;
    while (temp != NULL && temp2 != NULL) {
        int cmp = strcmp(temp->name, temp2->name);
        if (temp->prn == temp2->prn && cmp == 0){
            temp = temp->next;
            temp2 = temp2->next;
        } else{
            return 0;
        }
    }
    if (temp == NULL && temp2 == NULL){
        return 1;
    }
}