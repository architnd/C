Algorithm isFull()
{
   if (top == MAXSIZE - 1)
        return true;
   else
        return false;
}

Algorithm push(item)
{
   if (!isFull())
   {
       top = top + 1;
       stack[top] = item;
   }
}

Algorithm isEmpty()
{
   if (top == -1)
        return true;
   else
        return false;
}

Algorithm pop()
{
   if (!isEmpty())
   {
       temp = stack[top];
       top = top - 1;
       return temp;
   }
}

Algorithm in_post(inexp[])
{
   k = 0; i = 0;
   tkn = inexp[i];
   while (tkn != '\0')
   {
       if tkn is operand
           postexp[k] = inexp[i]; k++;
       else
       {
           if tkn == '('
               push('(');
           else if tkn == ')'
           {
               while ((tkn = pop()) != '(')
               {
                   postexp[k] = tkn; k++;
               }
           }
           else
           {
               while (stack not empty && isp(stk[top]) >= icp(tkn))
               {
                   postexp[k] = pop(); k++;
               }
               push(tkn);
           }
       }
       i++;
       tkn = inexp[i];
   }
   while stack not empty
   {
       postexp[k] = pop(); k++;
   }
}

Algorithm in_pre(inexp[])
{
   k=0; i=strlen(inexp)-1;
   tkn=inexp[i];

   while (i >= 0)
   {
       if tkn is operand
           pre_exp[k]=inexp[i]; k++;
       else
       {
           if tkn == ')'
               push(')');
           else if tkn == '('
           {
               while ((tkn=pop()) != ')')
               {
                   pre_exp[k]=tkn; k++;
               }
           }
           else
           {
               while (stack not empty && isp(stk[top]) > icp(tkn))
               {
                   pre_exp[k]=pop(); k++;
               }
               push(tkn);
           }
       }
       i--;
       tkn=inexp[i];
   }
   while stack not empty
       pre_exp[k]=pop(); k++;
   // reverse pre_exp to get prefix
}

Algorithm Post_infx(E)
   l = length(E)
   for i = 0 to l-1
   {
       x = next_token(E)
       case x:
           operand → push(x)
           operator →
               op2 = pop()
               op1 = pop()
               E1 = strcat('(', op1, x, op2, ')')
               push(E1)
   }
End

Algorithm Post_pre(E)
   l = length(E)
   for i = 0 to l-1
   {
       x = next_token(E)
       case x:
           operand → push(x)
           operator →
               op2 = pop()
               op1 = pop()
               E1 = strcat(x, op1, op2)
               push(E1)
   }
End

Algorithm Pre_infx(E)
   l = length(E)
   for i = l-1 downto 0
   {
       x = next_token(E)
       case x:
           operand → push(x)
           operator →
               op1 = pop()
               op2 = pop()
               E1 = strcat('(', op1, x, op2, ')')
               push(E1)
   }
End

Algorithm pre_post(E)
   l = length(E)
   for i = l-1 downto 0
   {
       x = next_token(E)
       case x:
           operand → push(x)
           operator →
               op1 = pop()
               op2 = pop()
               E1 = strcat(op1, op2, x)
               push(E1)
   }
End

Algorithm evaluate_postfix(E)
WHILE more input items exist
{
   If symb is operand
        push(opndstk, symb)
   else
   {
        opnd2 = pop(opndstk)
        opnd1 = pop(opndstk)
        value = apply(symb, opnd1, opnd2)
        push(opndstk, value)
   }
}
Result = pop(opndstk)

#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>
#include <string.h>

#define MAX 100

int operandStack[MAX], topOpnd = -1;
char operatorStack[MAX]; int topOptr = -1;

// Function prototypes
void pushOperand(int val);
int popOperand();
void pushOperator(char op);
char popOperator();
int precedence(char op);
int apply(char op, int a, int b);
int evaluate_infix(const char* expr);

// Stack operations
void pushOperand(int val) {
    operandStack[++topOpnd] = val;
}

int popOperand() {
    return operandStack[topOpnd--];
}

void pushOperator(char op) {
    operatorStack[++topOptr] = op;
}

char popOperator() {
    return operatorStack[topOptr--];
}

int precedence(char op) {
    if (op == '+' || op == '-') return 1;
    if (op == '*' || op == '/') return 2;
    return 0;
}

int apply(char op, int a, int b) {
    switch (op) {
        case '+': return a + b;
        case '-': return a - b;
        case '*': return a * b;
        case '/': return a / b;
    }
    return 0;
}

// Main infix evaluation function
int evaluate_infix(const char* expr) {
    int i = 0;
    while (expr[i] != '\0') {
        if (isspace(expr[i])) {
            i++;
            continue;
        }

        if (isdigit(expr[i])) {
            int num = 0;
            while (isdigit(expr[i])) {
                num = num * 10 + (expr[i] - '0');
                i++;
            }
            pushOperand(num);
        } 
        else if (expr[i] == '(') {
            pushOperator(expr[i]);
            i++;
        }
        else if (expr[i] == ')') {
            while (topOptr != -1 && operatorStack[topOptr] != '(') {
                char op = popOperator();
                int b = popOperand();
                int a = popOperand();
                pushOperand(apply(op, a, b));
            }
            popOperator(); // pop '('
            i++;
        }
        else { // operator
            while (topOptr != -1 && precedence(operatorStack[topOptr]) >= precedence(expr[i])) {
                char op = popOperator();
                int b = popOperand();
                int a = popOperand();
                pushOperand(apply(op, a, b));
            }
            pushOperator(expr[i]);
            i++;
        }
    }

    // Final evaluation
    while (topOptr != -1) {
        char op = popOperator();
        int b = popOperand();
        int a = popOperand();
        pushOperand(apply(op, a, b));
    }

    return popOperand();
}

int main() {
    char expr[MAX];
    printf("Enter infix expression: ");
    fgets(expr, MAX, stdin);
    expr[strcspn(expr, "\n")] = 0; // Remove trailing newline
    int result = evaluate_infix(expr);
    printf("Result: %d\n", result);
    return 0;
}

//complete this code for stack infix evaluation
// use " %[^\]s" instead of fgets


#include <stdio.h>
#include <stdlib.h>  // for atoi
#include <ctype.h>

#define MAX 50

// Stack for storing integers
int stack[MAX];
int top = -1;

// Stack functions
int isEmpty() {
    return top == -1;
}

int isFull() {
    return top == MAX - 1;
}

void push(int item) {
    if (isFull()) {
        printf("Stack Overflow\n");
    }
    else {
        stack[++top] = item;
    }
}

int pop() {
    if (!isEmpty()) {
        return stack[top--];
    }
    else {
        return -1;  // Stack is empty
    }
}

// Function to apply the operator to operands
int applyOp(int a, int b, char op) {
    switch(op) {
        case '+': return a + b;
        case '-': return a - b;
        case '*': return a * b;
        case '/': return b != 0 ? a / b : 0;  // Avoid divide by zero
        case '%': return b != 0 ? a % b : 0;
        case '^': {
            int res = 1;
            for (int i = 0; i < b; i++) res *= a;
            return res;
        }
        default: return 0;
    }
}

// Function to evaluate the postfix expression
int evaluatePostfix(char* postfix) {
    int i = 0;
    while (postfix[i] != '\0') {
        char ch = postfix[i];

        if (isspace(ch)) {
            i++;
            continue;
        }

        if (isdigit(ch)) {
            int num = 0;

            // Extract the full number (could be multiple digits)
            while (isdigit(postfix[i])) {
                num = num * 10 + (postfix[i] - '0');
                i++;
            }
            push(num);
        }
        else {
            // Operator case
            int b = pop();
            int a = pop();
            int result = applyOp(a, b, ch);
            push(result);
            i++;
        }
    }

    return pop();  // Final result is the only element left in the stack
}

int main() {
    char postfix[MAX];

    printf("Enter a postfix expression: ");
    // Use scanf to read the postfix expression without a newline
    scanf(" %[^\n]s", postfix);

    int result = evaluatePostfix(postfix);
    printf("Result = %d\n", result);

    return 0;
}

https://docs.google.com/presentation/d/1r2qXXulAxUfIROL5fk60ClezY7e3LWRoiJFBQHVudbE/edit?usp=drivesdk
